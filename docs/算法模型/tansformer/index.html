<!doctype html>
<html lang="zh-Hans" dir="ltr" class="docs-wrapper plugin-docs plugin-id-default docs-version-current docs-doc-page docs-doc-id-算法模型/tansformer" data-has-hydrated="false">
<head>
<meta charset="UTF-8">
<meta name="generator" content="Docusaurus v3.1.1">
<title data-rh="true">Transformer | 学习笔记</title><meta data-rh="true" name="viewport" content="width=device-width,initial-scale=1"><meta data-rh="true" name="twitter:card" content="summary_large_image"><meta data-rh="true" property="og:image" content="https://cttmayi.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" name="twitter:image" content="https://cttmayi.github.io/img/docusaurus-social-card.jpg"><meta data-rh="true" property="og:url" content="https://cttmayi.github.io/docs/算法模型/tansformer"><meta data-rh="true" property="og:locale" content="zh_Hans"><meta data-rh="true" name="docusaurus_locale" content="zh-Hans"><meta data-rh="true" name="docsearch:language" content="zh-Hans"><meta data-rh="true" name="docusaurus_version" content="current"><meta data-rh="true" name="docusaurus_tag" content="docs-default-current"><meta data-rh="true" name="docsearch:version" content="current"><meta data-rh="true" name="docsearch:docusaurus_tag" content="docs-default-current"><meta data-rh="true" property="og:title" content="Transformer | 学习笔记"><meta data-rh="true" name="description" content="全文参见一译//www.yiyibooks.cn/yiyibooks/AttentionIsAllYouNeed/index.html"><meta data-rh="true" property="og:description" content="全文参见一译//www.yiyibooks.cn/yiyibooks/AttentionIsAllYouNeed/index.html"><link data-rh="true" rel="icon" href="/img/favicon.ico"><link data-rh="true" rel="canonical" href="https://cttmayi.github.io/docs/算法模型/tansformer"><link data-rh="true" rel="alternate" href="https://cttmayi.github.io/docs/算法模型/tansformer" hreflang="zh-Hans"><link data-rh="true" rel="alternate" href="https://cttmayi.github.io/docs/算法模型/tansformer" hreflang="x-default"><link rel="alternate" type="application/rss+xml" href="/blog/rss.xml" title="学习笔记 RSS Feed">
<link rel="alternate" type="application/atom+xml" href="/blog/atom.xml" title="学习笔记 Atom Feed"><link rel="stylesheet" href="/assets/css/styles.00cf9dc1.css">
<script src="/assets/js/runtime~main.147177cc.js" defer="defer"></script>
<script src="/assets/js/main.ac48b2ca.js" defer="defer"></script>
</head>
<body class="navigation-with-keyboard">
<script>!function(){function t(t){document.documentElement.setAttribute("data-theme",t)}var e=function(){try{return new URLSearchParams(window.location.search).get("docusaurus-theme")}catch(t){}}()||function(){try{return localStorage.getItem("theme")}catch(t){}}();t(null!==e?e:"light")}(),function(){try{const c=new URLSearchParams(window.location.search).entries();for(var[t,e]of c)if(t.startsWith("docusaurus-data-")){var a=t.replace("docusaurus-data-","data-");document.documentElement.setAttribute(a,e)}}catch(t){}}()</script><div id="__docusaurus"><div role="region" aria-label="跳到主要内容"><a class="skipToContent_fXgn" href="#__docusaurus_skipToContent_fallback">跳到主要内容</a></div><nav aria-label="主导航" class="navbar navbar--fixed-top"><div class="navbar__inner"><div class="navbar__items"><button aria-label="切换导航栏" aria-expanded="false" class="navbar__toggle clean-btn" type="button"><svg width="30" height="30" viewBox="0 0 30 30" aria-hidden="true"><path stroke="currentColor" stroke-linecap="round" stroke-miterlimit="10" stroke-width="2" d="M4 7h22M4 15h22M4 23h22"></path></svg></button><a class="navbar__brand" href="/"><div class="navbar__logo"><img src="/img/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--light_NVdE"><img src="/img/logo.svg" alt="Logo" class="themedComponent_mlkZ themedComponent--dark_xIcU"></div><b class="navbar__title text--truncate">学习笔记</b></a><a aria-current="page" class="navbar__item navbar__link navbar__link--active" href="/docs/intro">AIGC</a><a class="navbar__item navbar__link" href="/blog">Blog</a></div><div class="navbar__items navbar__items--right"><a href="https://github.com/cttmayi" target="_blank" rel="noopener noreferrer" class="navbar__item navbar__link">GitHub<svg width="13.5" height="13.5" aria-hidden="true" viewBox="0 0 24 24" class="iconExternalLink_nPIU"><path fill="currentColor" d="M21 13v10h-21v-19h12v2h-10v15h17v-8h2zm3-12h-10.988l4.035 4-6.977 7.07 2.828 2.828 6.977-7.07 4.125 4.172v-11z"></path></svg></a><div class="toggle_vylO colorModeToggle_DEke"><button class="clean-btn toggleButton_gllP toggleButtonDisabled_aARS" type="button" disabled="" title="切换浅色/暗黑模式（当前为浅色模式）" aria-label="切换浅色/暗黑模式（当前为浅色模式）" aria-live="polite"><svg viewBox="0 0 24 24" width="24" height="24" class="lightToggleIcon_pyhR"><path fill="currentColor" d="M12,9c1.65,0,3,1.35,3,3s-1.35,3-3,3s-3-1.35-3-3S10.35,9,12,9 M12,7c-2.76,0-5,2.24-5,5s2.24,5,5,5s5-2.24,5-5 S14.76,7,12,7L12,7z M2,13l2,0c0.55,0,1-0.45,1-1s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S1.45,13,2,13z M20,13l2,0c0.55,0,1-0.45,1-1 s-0.45-1-1-1l-2,0c-0.55,0-1,0.45-1,1S19.45,13,20,13z M11,2v2c0,0.55,0.45,1,1,1s1-0.45,1-1V2c0-0.55-0.45-1-1-1S11,1.45,11,2z M11,20v2c0,0.55,0.45,1,1,1s1-0.45,1-1v-2c0-0.55-0.45-1-1-1C11.45,19,11,19.45,11,20z M5.99,4.58c-0.39-0.39-1.03-0.39-1.41,0 c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0s0.39-1.03,0-1.41L5.99,4.58z M18.36,16.95 c-0.39-0.39-1.03-0.39-1.41,0c-0.39,0.39-0.39,1.03,0,1.41l1.06,1.06c0.39,0.39,1.03,0.39,1.41,0c0.39-0.39,0.39-1.03,0-1.41 L18.36,16.95z M19.42,5.99c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06c-0.39,0.39-0.39,1.03,0,1.41 s1.03,0.39,1.41,0L19.42,5.99z M7.05,18.36c0.39-0.39,0.39-1.03,0-1.41c-0.39-0.39-1.03-0.39-1.41,0l-1.06,1.06 c-0.39,0.39-0.39,1.03,0,1.41s1.03,0.39,1.41,0L7.05,18.36z"></path></svg><svg viewBox="0 0 24 24" width="24" height="24" class="darkToggleIcon_wfgR"><path fill="currentColor" d="M9.37,5.51C9.19,6.15,9.1,6.82,9.1,7.5c0,4.08,3.32,7.4,7.4,7.4c0.68,0,1.35-0.09,1.99-0.27C17.45,17.19,14.93,19,12,19 c-3.86,0-7-3.14-7-7C5,9.07,6.81,6.55,9.37,5.51z M12,3c-4.97,0-9,4.03-9,9s4.03,9,9,9s9-4.03,9-9c0-0.46-0.04-0.92-0.1-1.36 c-0.98,1.37-2.58,2.26-4.4,2.26c-2.98,0-5.4-2.42-5.4-5.4c0-1.81,0.89-3.42,2.26-4.4C12.92,3.04,12.46,3,12,3L12,3z"></path></svg></button></div><div class="navbarSearchContainer_Bca1"></div></div></div><div role="presentation" class="navbar-sidebar__backdrop"></div></nav><div id="__docusaurus_skipToContent_fallback" class="main-wrapper mainWrapper_z2l0"><div class="docsWrapper_hBAB"><button aria-label="回到顶部" class="clean-btn theme-back-to-top-button backToTopButton_sjWU" type="button"></button><div class="docRoot_UBD9"><aside class="theme-doc-sidebar-container docSidebarContainer_YfHR"><div class="sidebarViewport_aRkj"><div class="sidebar_njMd"><nav aria-label="文档侧边栏" class="menu thin-scrollbar menu_SIkG"><ul class="theme-doc-sidebar-menu menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-1 menu__list-item"><a class="menu__link" href="/docs/intro">AIGC</a></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--active" aria-expanded="true" href="/docs/category/算法模型">算法模型</a><button aria-label="折叠侧边栏分类 &#x27;算法模型&#x27;" type="button" class="clean-btn menu__caret"></button></div><ul style="display:block;overflow:visible;height:auto" class="menu__list"><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/算法模型/CNN">CNN</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/算法模型/gpt.transformer">Transformer与注意力机制</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link" tabindex="0" href="/docs/算法模型/self-attention">Self-Attention</a></li><li class="theme-doc-sidebar-item-link theme-doc-sidebar-item-link-level-2 menu__list-item"><a class="menu__link menu__link--active" aria-current="page" tabindex="0" href="/docs/算法模型/tansformer">Transformer</a></li></ul></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/大模型">大模型</a><button aria-label="展开侧边栏分类 &#x27;大模型&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/category/开源库">开源库</a><button aria-label="展开侧边栏分类 &#x27;开源库&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist" aria-expanded="false" href="/docs/Prompt/">提示工程</a><button aria-label="展开侧边栏分类 &#x27;提示工程&#x27;" type="button" class="clean-btn menu__caret"></button></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/学习资源/开源项目">学习资源</a></div></li><li class="theme-doc-sidebar-item-category theme-doc-sidebar-item-category-level-1 menu__list-item menu__list-item--collapsed"><div class="menu__list-item-collapsible"><a class="menu__link menu__link--sublist menu__link--sublist-caret" aria-expanded="false" href="/docs/相关知识/Embedding">相关知识</a></div></li></ul></nav></div></div></aside><main class="docMainContainer_TBSr"><div class="container padding-top--md padding-bottom--lg"><div class="row"><div class="col docItemCol_VOVn"><div class="docItemContainer_Djhp"><article><nav class="theme-doc-breadcrumbs breadcrumbsContainer_Z_bl" aria-label="页面路径"><ul class="breadcrumbs" itemscope="" itemtype="https://schema.org/BreadcrumbList"><li class="breadcrumbs__item"><a aria-label="主页面" class="breadcrumbs__link" href="/"><svg viewBox="0 0 24 24" class="breadcrumbHomeIcon_YNFT"><path d="M10 19v-5h4v5c0 .55.45 1 1 1h3c.55 0 1-.45 1-1v-7h1.7c.46 0 .68-.57.33-.87L12.67 3.6c-.38-.34-.96-.34-1.34 0l-8.36 7.53c-.34.3-.13.87.33.87H5v7c0 .55.45 1 1 1h3c.55 0 1-.45 1-1z" fill="currentColor"></path></svg></a></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item"><a class="breadcrumbs__link" itemprop="item" href="/docs/category/算法模型"><span itemprop="name">算法模型</span></a><meta itemprop="position" content="1"></li><li itemscope="" itemprop="itemListElement" itemtype="https://schema.org/ListItem" class="breadcrumbs__item breadcrumbs__item--active"><span class="breadcrumbs__link" itemprop="name">Transformer</span><meta itemprop="position" content="2"></li></ul></nav><div class="tocCollapsible_ETCw theme-doc-toc-mobile tocMobile_ITEo"><button type="button" class="clean-btn tocCollapsibleButton_TO0P">本页总览</button></div><div class="theme-doc-markdown markdown"><h1>Transformer</h1>
<p>全文参见一译:<a href="https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html" target="_blank" rel="noopener noreferrer">https://www.yiyibooks.cn/yiyibooks/Attention_Is_All_You_Need/index.html</a></p>
<p>更多论文的中英文对照翻译参见：<a href="https://github.com/yiyibooks/nlp_machine_learning_papers" target="_blank" rel="noopener noreferrer">https://github.com/yiyibooks/nlp_machine_learning_papers</a></p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="attention-is-all-you-need">Attention Is All You Need<a href="#attention-is-all-you-need" class="hash-link" aria-label="Attention Is All You Need的直接链接" title="Attention Is All You Need的直接链接">​</a></h2>
<p>同等贡献。 名单顺序随机。 Jakob提出用self-attention替换RNN并开始努力验证这个想法。 Ashish和Illia设计并实现第一个Transformer模型，并在这项工作中的各个方面其中至关重要的作用。 Noam提出缩放版的点积attention、multi-head attention和与参数无关的位置表示，并成为在几乎每个细节中都涉及的另外一个人。 Niki在我们最初的代码库和tensor2tensor中设计、实现、调优和评估了无数的模型变体。 Llion还尝试了新的模型变体，负责我们的初始代码库，以及高效的推断和可视化。 Lukasz和Aidan花费了无数的时间来设计tensor2tensor的各个部分，取代了我们之前的代码库，极大地改进了结果并大大加快了我们的研究。</p>
<p>第31届神经网络信息处理系统会议（NIPS 2017），美国加州长滩市。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="摘要">摘要<a href="#摘要" class="hash-link" aria-label="摘要的直接链接" title="摘要的直接链接">​</a></h2>
<p>主流序列转导模型基于复杂的循环神经网络或卷积神经网络，这些神经网络包含一个编码器和一个解码器。 性能最好的模型还通过attention机制将编码器和解码器连接起来。 我们提出一种新的简单的网络架构Transformer，仅基于attention机制并完全避免循环和卷积。 对两个机器翻译任务的实验表明，这些模型在质量上更加优越、并行性更好并且需要的  训练时间显著减少。 我们的模型在WMT 2014英语-德语翻译任务上达到28.4 BLEU，超过现有最佳结果（包括整合模型）2个BLEU。 在WMT 2014英语-法语翻译任务中，我们的模型建立了单模型新的最先进的BLEU分数41.8，它在8个GPU上训练了3.5天，这个时间只是目前文献中记载的最好的模型训练成本的一小部分。 通过在解析大量训练数据和有限训练数据的两种情况下将其应用到English constituency，我们表明Transformer可以很好地推广到其他任务。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="1-简介">1 简介<a href="#1-简介" class="hash-link" aria-label="1 简介的直接链接" title="1 简介的直接链接">​</a></h2>
<p>在序列建模和转换问题中，如语言建模和机器翻译[35, 2, 5]，循环神经网络特别是长短期记忆[13]和门控循环[7]神经网络，已经被确立为最先进的方法。 自那以后，许多努力一直在推动循环语言模型和编码器-解码器架构的界限[38, 24, 15]。</p>
<p>循环模型通常是对输入和输出序列的符号位置进行因子计算。 通过在计算期间将位置与步骤对齐，它们根据前一步的隐藏状态ht-1和输入产生位置t的隐藏状态序列ht。这种固有的顺序特性阻碍样本训练的并行化，这在更长的序列长度上变得至关重要，因为有限的内存限制样本的批次大小。 最近的工作通过巧妙的因子分解[21]和条件计算[32]在计算效率方面取得重大进展，后者还同时提高了模型性能。 然而，顺序计算的基本约束依然存在。</p>
<p>在各种任务中，attention机制已经成为序列建模和转导模型不可或缺的一部分，它可以建模依赖关系而不考虑其在输入或输出序列中的距离[2, 19]。 除少数情况外[27]，这种attention机制都与循环网络一起使用。</p>
<p>在这项工作中我们提出Transformer，这种模型架构避免循环并完全依赖于attention机制来绘制输入和输出之间的全局依赖关系。Transformer允许进行更多的并行化，并且可以在八个P100 GPU上接受少至十二小时的训练后达到翻译质量的新的最佳结果。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="2-背景">2 背景<a href="#2-背景" class="hash-link" aria-label="2 背景的直接链接" title="2 背景的直接链接">​</a></h2>
<p>减少顺序计算的目标也构成扩展的神经网络GPU [16]、ByteNet [18]和ConvS2S [9]的基础，它们都使用卷积神经网络作为基本构建模块、并行计算所有输入和输出位置的隐藏表示。 在这些模型中，关联任意两个输入和输出位置的信号所需的操作次数会随着位置之间的距离而增加，ConvS2S是线性增加，而ByteNet是对数增加。 这使得学习远距离位置之间的依赖关系变得更加困难[12]。 在Transformer中，这中操作减少到固定的次数，尽管由于对用attention权重化的位置取平均降低了效果，但是我使用Multi-Head Attention进行抵消，具体描述见 3.2。</p>
<p>Self-attention，有时称为intra-attention，是一种attention机制，它关联单个序列的不同位置以计算序列的表示。 Self-attention已成功用于各种任务，包括阅读理解、摘要概括、文本蕴涵和学习与任务无关的句子表征[4, 27, 28, 22]。</p>
<p>端到端的内存网络基于循环attention机制，而不是序列对齐的循环，并且已被证明在简单语言的问题回答和语言建模任务中表现良好[34]。</p>
<p>然而，就我们所知，Transformer是第一个完全依靠self-attention来计算输入和输出表示而不使用序列对齐RNN或卷积的转导模型。 在下面的章节中，我们将描述Transformer、引出self-attention并讨论它相对[17, 18]和[9]几个模型的优势。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="3-模型架构">3 模型架构<a href="#3-模型架构" class="hash-link" aria-label="3 模型架构的直接链接" title="3 模型架构的直接链接">​</a></h2>
<p>图1： Transformer — 模型架构。</p>
<p>大部分神经序列转导模型都有一个编码器-解码器结构[5, 2, 35]。 这里，编码器映射一个用符号表示的输入序列(x1,...,xn) 到一个连续的表示z= (z1,...,zn)。 根据z，解码器生成符号的一个输出序列(y1,...,ym) ，一次一个元素。 在每一步中，模型都是自回归的[10]，当生成下一个时，消耗先前生成的符号作为附加输入。</p>
<p>Transformer遵循这种整体架构，编码器和解码器都使用self-attention堆叠和point-wise、完全连接的层，分别显示在图1的左边和右边。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="31-编码器和解码器堆栈">3.1 编码器和解码器堆栈<a href="#31-编码器和解码器堆栈" class="hash-link" aria-label="3.1 编码器和解码器堆栈的直接链接" title="3.1 编码器和解码器堆栈的直接链接">​</a></h3>
<p>编码器： 编码器由N = 6 个完全相同的层堆叠而成。 每一层都有两个子层。 第一层是一个multi-head self-attention机制，第二层是一个简单的、位置完全连接的前馈网络。 我们对每个子层再采用一个残差连接[11] ，接着进行层标准化[1]。 也就是说，每个子层的输出是LayerNorm(x + Sublayer(x))，其中Sublayer(x) 是由子层本身实现的函数。 为了方便这些残差连接，模型中的所有子层以及嵌入层产生的输出维度都为dmodel = 512。</p>
<p>解码器： 解码器同样由N = 6 个完全相同的层堆叠而成。 除了每个编码器层中的两个子层之外，解码器还插入第三个子层，该层对编码器堆栈的输出执行multi-head attention。 与编码器类似，我们在每个子层再采用残差连接，然后进行层标准化。 我们还修改解码器堆栈中的self-attention子层，以防止位置关注到后面的位置。 这种掩码结合将输出嵌入偏移一个位置，确保对位置的预测 i 只能依赖小于i 的已知输出。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="32-attention">3.2 Attention<a href="#32-attention" class="hash-link" aria-label="3.2 Attention的直接链接" title="3.2 Attention的直接链接">​</a></h3>
<p>Attention函数可以描述为将query和一组key-value对映射到输出，其中query、key、value和输出都是向量。 输出为value的加权和，其中分配给每个value的权重通过query与相应key的兼容函数来计算。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="321-缩放版的点积attention">3.2.1 缩放版的点积attention<a href="#321-缩放版的点积attention" class="hash-link" aria-label="3.2.1 缩放版的点积attention的直接链接" title="3.2.1 缩放版的点积attention的直接链接">​</a></h4>
<p>我们称我们特殊的attention为“缩放版的点积attention”（图 2）。 输入由query、dk 维的key和dv 维的value组成。 我们计算query和所有key的点积、用
相除，然后应用一个softmax函数以获得值的权重。</p>
<p>在实践中，我们同时计算一组query的attention函数，并将它们组合成一个矩阵Q。 key和value也一起打包成矩阵 K 和 V 。 我们计算输出矩阵为：</p>
<p>两个最常用的attention函数是加法attention[2]和点积（乘法）attention。 除了缩放因子
之外，点积attention与我们的算法相同。 加法attention使用具有单个隐藏层的前馈网络计算兼容性函数。 虽然两者在理论上的复杂性相似，但在实践中点积attention的速度更快、更节省空间，因为它可以使用高度优化的矩阵乘法代码来实现。</p>
<p>当dk的值比较小的时候，这两个机制的性能相差相近，当dk比较大时，加法attention比不带缩放的点积attention性能好[3]。 我们怀疑，对于很大的dk值，点积大幅度增长，将softmax函数推向具有极小梯度的区域4。 为了抵消这种影响，我们缩小点积
倍。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="322-multi-head-attention">3.2.2 Multi-Head Attention<a href="#322-multi-head-attention" class="hash-link" aria-label="3.2.2 Multi-Head Attention的直接链接" title="3.2.2 Multi-Head Attention的直接链接">​</a></h4>
<p>图2： （左）缩放版的点积attention。 （右）Multi-Head Attention，由多个并行运行的attention层组成。</p>
<p>我们发现将query、key和value分别用不同的、学到的线性映射h倍到dk、dk和dv维效果更好，而不是用d model维的query、key和value执行单个attention函数。 基于每个映射版本的query、key和value，我们并行执行attention函数，产生dv 维输出值。 将它们连接并再次映射，产生最终值，如图所示 2。</p>
<p>Multi-head attention允许模型的不同表示子空间联合关注不同位置的信息。 如果只有一个attention head，它的平均值会削弱这个信息。</p>
<p>其中，映射为参数矩阵WiQ ∈ ℝdmodel×dk , WiK ∈ ℝdmodel×dk , WiV ∈ ℝdmodel×dv 及W O ∈ ℝhdv×dmodel。</p>
<p>在这项工作中，我们采用h = 8 个并行attention层或head。 对每个head，我们使用dk =dv =dmodel ∕ h = 64。 由于每个head的大小减小，总的计算成本与具有全部维度的单个head attention相似。</p>
<h4 class="anchor anchorWithStickyNavbar_LWe7" id="323-attention在我们的模型中的应用">3.2.3 Attention在我们的模型中的应用<a href="#323-attention在我们的模型中的应用" class="hash-link" aria-label="3.2.3 Attention在我们的模型中的应用的直接链接" title="3.2.3 Attention在我们的模型中的应用的直接链接">​</a></h4>
<p>Transformer使用以3种方式使用multi-head attention：</p>
<p>在“编码器—解码器attention”层，query来自前一个解码器层，key和value来自编码器的输出。 这允许解码器中的每个位置能关注到输入序列中的所有位置。 这模仿序列到序列模型中典型的编码器—解码器的attention机制，例如[38, 2, 9]。
编码器包含self-attention层。 在self-attention层中，所有的key、value和query来自同一个地方，在这里是编码器中前一层的输出。编码器中的每个位置都可以关注编码器上一层的所有位置。
类似地，解码器中的self-attention层允许解码器中的每个位置都关注解码器中直到并包括该位置的所有位置。 我们需要防止解码器中的向左信息流来保持自回归属性。 通过屏蔽softmax的输入中所有不合法连接的值（设置为-∞），我们在缩放版的点积attention中实现。 见图 2.</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="33-基于位置的前馈网络">3.3 基于位置的前馈网络<a href="#33-基于位置的前馈网络" class="hash-link" aria-label="3.3 基于位置的前馈网络的直接链接" title="3.3 基于位置的前馈网络的直接链接">​</a></h3>
<p>除了attention子层之外，我们的编码器和解码器中的每个层都包含一个完全连接的前馈网络，该前馈网络单独且相同地应用于每个位置。 它由两个线性变换组成，之间有一个ReLU激活。</p>
<p>尽管线性变换在不同位置上是相同的，但它们使用层与层之间的不同参数。 它的另一种描述方式是两个内核大小为1的卷积。 输入和输出的维度为dmodel = 512，内部层的维度为dff = 2048。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="34-嵌入和softmax">3.4 嵌入和Softmax<a href="#34-嵌入和softmax" class="hash-link" aria-label="3.4 嵌入和Softmax的直接链接" title="3.4 嵌入和Softmax的直接链接">​</a></h3>
<p>与其他序列转导模型类似，我们使用学习到的嵌入将输入词符和输出词符转换为维度为dmodel的向量。 我们还使用普通的线性变换和softmax函数将解码器输出转换为预测的下一个词符的概率。 在我们的模型中，两个嵌入层之间和pre-softmax线性变换共享相同的权重矩阵，类似于[30]。 在嵌入层中，我们将这些权  重乘以
。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="35-位置编码">3.5 位置编码<a href="#35-位置编码" class="hash-link" aria-label="3.5 位置编码的直接链接" title="3.5 位置编码的直接链接">​</a></h3>
<p>由于我们的模型不包含循环和卷积，为了让模型利用序列的顺序，我们必须注入序列中关于词符相对或者绝对位置的一些信息。 为此，我们将“位置编码”添加到编码器和解码器堆栈底部的输入嵌入中。 位置编码和嵌入的维度dmodel相同，所以它们俩可以相加。 有多种位置编码可以选择，例如通过学习得到的位置编码和固定的位置编码[9]。</p>
<p>在这项工作中，我们使用不同频率的正弦和余弦函数：</p>
<p>PE(pos,2i)=sin(pos ∕100002i ∕ dmodel)</p>
<p>PE(pos,2i+1)=cos(pos ∕100002i ∕ dmodel)</p>
<p>其中pos 是位置，i 是维度。 也就是说，位置编码的每个维度对应于一个正弦曲线。 这些波长形成一个几何级数，从2π 到10000 ⋅ 2π。 我们选择这个函数是因为我们假设它允许模型很容易学习对相对位置的关注，因为对任意确定的偏移k, PEpos+k可以表示为PEpos的线性函数。</p>
<p>我们还使用学习到的位置嵌入9进行了试验，发现这两个版本产生几乎相同的结果（参见表 3 行(E)）。 我们选择了正弦曲线，因为它可以允许模型推断比训练期间遇到的更长的序列。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="4-为什么选择self-attention">4 为什么选择Self-Attention<a href="#4-为什么选择self-attention" class="hash-link" aria-label="4 为什么选择Self-Attention的直接链接" title="4 为什么选择Self-Attention的直接链接">​</a></h2>
<p>本节，我们比较self-attention与循环层和卷积层的各个方面，它们通常用于映射变长的符号序列表示(x1,...,xn) 到另一个等长的序列(z1,...,zn)，其中xi,zi ∈ ℝd，例如一个典型的序列转导编码器 或解码器中的隐藏层。 我们使用self-attention是考虑到解决三个问题。</p>
<p>一个是每层计算的总复杂度。 另一个是可以并行的计算量，以所需的最小顺序操作的数量来衡量。</p>
<p>第三个是网络中长距离依赖之间的路径长度。 学习长距离依赖性是许多序列转导任务中的关键挑战。 影响学习这种依赖性能力的一个关键因素是前向和后向信号必须在网络中传播的路径长度。 输入和输出序列中任意位置组合之间的这些路径越短，学习远距离依赖性就越容易[12]。因此，我们还比较了由不同图层类型组成的网络中任意两个输入和输出位置之间的最大路径长度。</p>
<p>表1： 不同图层类型的最大路径长度、每层复杂度和最少顺序操作数。 n 为序列的长度，d 为表示的维度，k 为卷积的核的大小，r 为受限self-attention中邻域的大小。</p>
<p>图层类型每层复杂度顺序最大路径长度操作</p>
<p>如表1所示，self-attention层将所有位置连接到恒定数量的顺序执行的操作，而循环层需要O(n) 顺序操作。 在计算复杂性方面，当序列长度n 小于表示维度d 时，self-attention层比循环层快，这是机器翻译中最先进的模型最常见情况，例如单词[38]表示法和字节对[31]表示法。为了提高涉及很长序列的任务的计算性能，可以将self-attention限制在仅考虑大小为r 的邻域。 这会将最大路径长度增加到O(n ∕ r)。 我们计划在未来的工作中进一步调查这种方法。</p>
<p>核宽度为k &lt; n的单层卷积不会连接每一对输入和输出的位置。 要这么做，在邻近核的情况下需要O(n∕k) 个卷积层， 在扩展卷积的情况下需要O(logk(n)) 个层[18]，它们增加了网络中任意两个位置之间的最长路径的长度。 卷积层通常比循环层更昂贵，与因子k有关。然而，可分卷积[6]大幅减少复杂度到O(k ⋅n⋅d + n⋅d2)。 然而，即使k = n，一个可分卷积的复杂度等同于self-attention层和point-wise前向层的组合，即我们的模型采用的方法。</p>
<p>间接的好处是self-attention可以产生更可解释的模型。 我们从我们的模型中研究attention的分布，并在附录中展示和讨论示例。 每个attention head不仅清楚地学习到执行不同的任务，许多似乎展现与句子的句法和语义结构的行为。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="5-训练">5 训练<a href="#5-训练" class="hash-link" aria-label="5 训练的直接链接" title="5 训练的直接链接">​</a></h2>
<p>本节介绍我们的模型训练方法。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="51-训练数据和批次">5.1 训练数据和批次<a href="#51-训练数据和批次" class="hash-link" aria-label="5.1 训练数据和批次的直接链接" title="5.1 训练数据和批次的直接链接">​</a></h3>
<p>我们在标准的WMT 2014英语-德语数据集上进行了训练，其中包含约450万个句子对。 这些句子使用字节对编码[3]进行编码，源语句和目标语句共享大约37000个词符的词汇表。 对于英语-法语翻译，我们使用大得多的WMT 2014英法数据集，它包含3600万个句子，并将词符分成32000个word-piece词汇表[38]。 序列长度相近的句子一起进行批处理。 每个训练批次的句子对包含大约25000个源词符和25000个目标词符。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="52-硬件和时间">5.2 硬件和时间<a href="#52-硬件和时间" class="hash-link" aria-label="5.2 硬件和时间的直接链接" title="5.2 硬件和时间的直接链接">​</a></h3>
<p>我们在一台具有8个NVIDIA P100 GPU的机器上训练我们的模型。 使用本文描述的超参数的基础模型，每个训练步骤耗时约0.4秒。 我们的基础模型共训练了10万步或12小时。 For our big models,(described on the bottom line of table 3), step time was 1.0 seconds. 大模  型训练了30万步（3.5天）。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="53-优化">5.3 优化<a href="#53-优化" class="hash-link" aria-label="5.3 优化的直接链接" title="5.3 优化的直接链接">​</a></h3>
<p>我们使用Adam优化[20]，其中β1 = 0.9, β2 = 0.98 及ϵ = 10-9。 我们根据以下公式在训练过程中改变学习率：</p>
<p>这对应于在第一次warmup_steps 步骤中线性地增加学习速率，并且随后将其与步骤数的平方根成比例地减小。 我们使用warmup_steps = 4000。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="54-正则化">5.4 正则化<a href="#54-正则化" class="hash-link" aria-label="5.4 正则化的直接链接" title="5.4 正则化的直接链接">​</a></h3>
<p>训练期间我们采用三种正则化：</p>
<p>残差丢弃 我们将丢弃[33]应用到每个子层的输出，在将它与子层的输入相加和规范化之前。 此外，在编码器和解码器堆栈中，我们将丢弃应用到嵌入和位置编码的和。 对于基本模型，我们使用Pdrop = 0.1丢弃率。</p>
<p>Label Smoothing 在训练过程中，我们使用的label smoothing的值为ϵls = 0.1[36]。 这让模型不易理解，因为模型学得更加不确定，但提高了准确性和BLEU得分。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="6-结果">6 结果<a href="#6-结果" class="hash-link" aria-label="6 结果的直接链接" title="6 结果的直接链接">​</a></h2>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="61-机器翻译">6.1 机器翻译<a href="#61-机器翻译" class="hash-link" aria-label="6.1 机器翻译的直接链接" title="6.1 机器翻译的直接链接">​</a></h3>
<p>表2： Transformer在英语-德语和英语-法语newstest2014测试中获得的BLEU分数比以前的最新模型的分数更好，且训练成本只是它们的一小部分。</p>
<p>在WMT 2014英语-德语翻译任务中，大型transformer模型（表2中的Transformer (big)）比以前报道的最佳模型（包 括整合模型）高出2.0个BLEU以上，确立了一个全新的最高BLEU分数为28.4。 该模型的配置列在表3的底部。 训练在8 个P100 GPU上花费3.5 天。 即使我们的基础模型也超过了以前发布的所有模型和整合模型，且训练成本只是这些模型的一小部分。</p>
<p>在WMT 2014英语-法语翻译任务中，我们的大型模型的BLEU得分为41.0，超过了之前发布的所有单一模型，训练成本低于先前最先进模型的1 ∕ 4 。 英语-法语的Transformer (big) 模型使用丢弃率为Pdrop = 0.1，而不是0.3。</p>
<p>对于基础模型，我们使用的单个模型来自最后5个检查点的平均值，这些检查点每10分钟写一次。 对于大型模型，我们对最后20个检查点进行了平均。 我们使用beam search，beam大小为4 ，长度惩罚α = 0.6 [38]。 这些超参数是在开发集上进行实验后选定的。 在推断时，我们设置最大输出长度为输入长度+50，但在可能时尽早终止[38]。</p>
<p>表2总结了我们的结果，并将我们的翻译质量和训练成本与文献中的其他模型体系结构进行了比较。 我们通过将训练时间、所使用的GPU的数量以及每个GPU的持续单精度浮点能力的估计相乘来估计用于训练模型的浮点运算的数量5。</p>
<h3 class="anchor anchorWithStickyNavbar_LWe7" id="62-模型的变体">6.2 模型的变体<a href="#62-模型的变体" class="hash-link" aria-label="6.2 模型的变体的直接链接" title="6.2 模型的变体的直接链接">​</a></h3>
<p>表3： Transformer架构的变体。 未列出的值与基本模型的值相同。 所有指标都基于英文到德文翻译开发集newstest2013。 Listed perplexities are per-wordpiece, according to our byte-pair encoding, and should not be compared to per-word perplexities.</p>
<p>为了评估Transformer不同组件的重要性，我们以不同的方式改变我们的基础模型，测量开发集newstest2013上英文-德文翻译的性能变化。  我们使用前一节所述的beam搜索，但没有平均检查点。 我们在表中列出这些结果 3.</p>
<p>在表3的行（A）中，我们改变attention head的数量和attention key和value的维度，保持计算量不变，如3.2.2节所述。 虽然只有一个head attention比最佳设置差0.9 BLEU，但质量也随着head太多而下降。</p>
<p>在表3行（B）中，我们观察到减小key的大小dk会有损模型质量。 这表明确定兼容性并不容易，并且比点积更复杂的兼容性函数可能更有用。我们在行（C）和（D）中进一步观察到，如预期的那样，更大的模型更好，并且丢弃对避免过度拟合非常有帮助。 在行（E）中，我们用学习到的位置嵌入[9]来替换我们的正弦位置编码，并观察到与基本模型几乎相同的结果。</p>
<h2 class="anchor anchorWithStickyNavbar_LWe7" id="7-结论">7 结论<a href="#7-结论" class="hash-link" aria-label="7 结论的直接链接" title="7 结论的直接链接">​</a></h2>
<p>在这项工作中，我们提出了Transformer，第一个完全基于关注的序列转导模型，用multi-headed self-attention取代了编码器-解码器架构中最常用的循环层。</p>
<p>对于翻译任务，Transformer可以比基于循环或卷积层的体系结构训练更快。 在WMT 2014英语-德语和WMT 2014英语-法语翻译任务中，我们取得了最好的结果。 在前面的任务中，我们最好的模型甚至胜过以前报道过的所有整合模型。</p>
<p>我们对基于attention的模型的未来感到兴奋，并计划将它们应用于其他任务。 我们计划将Transformer扩展到除文本之外的涉及输入和输出模式的问题，并调查局部的、受限attention机制以有效处理大型输入和输出，如图像、音频和视频。 让生成具有更少的顺序性是我们的另一个研究目标。</p>
<p>我们用于训练和评估模型的代码可以在<a href="https://github.com/tensorflow/tensor2tensor" target="_blank" rel="noopener noreferrer">https://github.com/tensorflow/tensor2tensor</a>上找到。</p>
<p>致谢 我们感谢Nal Kalchbrenner和Stephan Gouws富有成效的评论、更正和灵感。</p>
<p>4为了说明点积为什么变大，假设q和k的组成是均值为0和方差为1的独立随机变量。 那么它们的点积q ⋅ k = ∑ i=1dk qi ki 的均值为0，方差为dk。</p>
<p>5对于K80、K40、M40和P100，我们分别使用2.8、3.7、6.0和9.5 TFLOPS的值。</p></div></article><nav class="pagination-nav docusaurus-mt-lg" aria-label="文件选项卡"><a class="pagination-nav__link pagination-nav__link--prev" href="/docs/算法模型/self-attention"><div class="pagination-nav__sublabel">上一页</div><div class="pagination-nav__label">Self-Attention</div></a><a class="pagination-nav__link pagination-nav__link--next" href="/docs/category/大模型"><div class="pagination-nav__sublabel">下一页</div><div class="pagination-nav__label">大模型</div></a></nav></div></div><div class="col col--3"><div class="tableOfContents_bqdL thin-scrollbar theme-doc-toc-desktop"><ul class="table-of-contents table-of-contents__left-border"><li><a href="#attention-is-all-you-need" class="table-of-contents__link toc-highlight">Attention Is All You Need</a></li><li><a href="#摘要" class="table-of-contents__link toc-highlight">摘要</a></li><li><a href="#1-简介" class="table-of-contents__link toc-highlight">1 简介</a></li><li><a href="#2-背景" class="table-of-contents__link toc-highlight">2 背景</a></li><li><a href="#3-模型架构" class="table-of-contents__link toc-highlight">3 模型架构</a><ul><li><a href="#31-编码器和解码器堆栈" class="table-of-contents__link toc-highlight">3.1 编码器和解码器堆栈</a></li><li><a href="#32-attention" class="table-of-contents__link toc-highlight">3.2 Attention</a></li><li><a href="#33-基于位置的前馈网络" class="table-of-contents__link toc-highlight">3.3 基于位置的前馈网络</a></li><li><a href="#34-嵌入和softmax" class="table-of-contents__link toc-highlight">3.4 嵌入和Softmax</a></li><li><a href="#35-位置编码" class="table-of-contents__link toc-highlight">3.5 位置编码</a></li></ul></li><li><a href="#4-为什么选择self-attention" class="table-of-contents__link toc-highlight">4 为什么选择Self-Attention</a></li><li><a href="#5-训练" class="table-of-contents__link toc-highlight">5 训练</a><ul><li><a href="#51-训练数据和批次" class="table-of-contents__link toc-highlight">5.1 训练数据和批次</a></li><li><a href="#52-硬件和时间" class="table-of-contents__link toc-highlight">5.2 硬件和时间</a></li><li><a href="#53-优化" class="table-of-contents__link toc-highlight">5.3 优化</a></li><li><a href="#54-正则化" class="table-of-contents__link toc-highlight">5.4 正则化</a></li></ul></li><li><a href="#6-结果" class="table-of-contents__link toc-highlight">6 结果</a><ul><li><a href="#61-机器翻译" class="table-of-contents__link toc-highlight">6.1 机器翻译</a></li><li><a href="#62-模型的变体" class="table-of-contents__link toc-highlight">6.2 模型的变体</a></li></ul></li><li><a href="#7-结论" class="table-of-contents__link toc-highlight">7 结论</a></li></ul></div></div></div></div></main></div></div></div><footer class="footer footer--dark"><div class="container container-fluid"><div class="footer__bottom text--center"><div class="footer__copyright">Copyright © 2024 My Project, Inc. Built with Docusaurus.</div></div></div></footer></div>
</body>
</html>