---
title: ATPCS(ARM-Thumb过程调用标准)
tags: [ARM]
authors: cttmayi
---

基本ATPCS规定了在子程序调用时的一些基本规则，包括下面四方面的内容。

1. 各寄存器的使用规则及其相应的名称。
2. 数据栈的使用规则。
3. 参数传递的规则。
4. 子程序结果的返回规则。

寄存器的使用规则及其相应的名称
===
寄存器的使用必须满足下面的规则。

子程序间通过寄存器R0～R3来传递参数，被调用的子程序在返回前无需恢复寄存器R0～R3的内容。

在子程序中，使用寄存器R4～R11保存局部变量，这时寄存器可以记作V1～V8。如果在子程序中用到了寄存器V1～V8中的某些寄存器，子程序进 入时必须保存这些寄存器的值，在返回前必须恢复这些寄存器的值；对于子程序中没有用到的寄存器则不必进行这些操作。在Thumb程序中，通常只能使用寄存 器R4～R7来保存局部变量。

寄存器R12用作子程序间的Scratch寄存器(用于保存SP， 在函数返回时使用该寄存器出栈)，记作IP。

寄存器R13用作数据栈指针，记作SP。在子程序中寄存器R13不能用作其他用途。寄存器SP在进入子程序时的值和退出子程序的值必须相等。

寄存器R14称为连接寄存器，记作LR。它用作保存子程序的返回地址。如果在子程序中保存了返回地址，寄存器R14则可以用作其他用途。

寄存器R15是程序计数器，记作PC。它不能用作其他用途。

ATPCS中的各寄存器在ARM编译器和汇编器中都是预定义的。

表4-1 总结了在ATPCS中各寄存器的使用规则及其名称。

表4-1 寄存器的使用规则

| 寄存器| 别名| 特殊名称| 使用规则 |
| --- | --- | --- | --- |
| R15 | | PC | 程序计数器 |
| R14 | | LR | 连接寄存器 |
| R13 | | SP | 数据栈指针 |
| R12 | | IP | 子程序内部调用的Scratch寄存器 |
| R11 | V8 | | ARM状态局部变量寄存器8 |
| R10 | V7 | Sl | ARM状态局部变量寄存器7 |
| R9 | V6 | SB | ARM状态局部变量寄存器6, 在支持RWPI的ATPCS, 中为静态基址寄存器 |
| R8 | V5 |	 | ARM状态局部变量寄存器5 |
| R7 | V4 | WR | ARM状态局部变量寄存器4, Thumb状态工作寄存器 |
| R6 | V3 |	 | 局部变量寄存器3 |
| R5 | V2 |	 | 局部变量寄存器2 |
| R4 | V1 |	 | 局部变量寄存器1 |
| R3 | A4 |	 | 参数/结果/Scratch寄存器4 |
| R2 | A3 |	 | 参数/结果/Scratch寄存器3 |
| R1 | A2 |	 | 参数/结果/Scratch寄存器2 |
| R0 | A1 |	 | 参数/结果/Scratch寄存器1 |

数据栈的使用规则
===

指针是保存了栈顶地址的寄存器值。栈指针通常可以指向不同的位置。一般的，栈可以有以下四种数据栈。

FD：Full Descending
ED：Empty Descending
FA：Full Ascending
EA：Empty Ascending

当栈指针指向与栈顶元素时，称为Full栈。当栈指针指向与栈顶元素相邻的一个元素时，称为Empty栈。数据栈的增长方向也可以不同，当数据栈向 内存减少的地址方向增长时，称为Descending栈；反之称为Ascending栈。ARM的ATPCS规定默认的数据栈为Full Descending(FD)类型，并且对数据栈的操作是8字节对齐的。

参数传递的规则
===

根据参数个数是否固定可以将子程序参数传递规则分为以下两种。

- 参数个数可变的子程序参数传递规则
对于参数个数可变的子程序，但参数不超过四个时，可以使用寄存器R0～R3来传递参数；当参数超过四个时，还可以使用数据栈来传递参数。在传递参数 时，将所有参数看作是存放在连续的内存单元中的字数据。然后，依次将各字数据传送到寄存器R0、R1、R2、R3中，如果参数多于四个，则将剩余的字数据 传送到数据栈中，入栈的顺序与参数顺序相反，即最后一个字数据先入栈。

- 参数个数固定的子程序参数传递规则
对于参数个数固定的子程序，参数传递与参数个数可变的子程序参数传递的规则不同，如果系统包含浮点运算的硬件部件，浮点参数将按各个浮点参数按顺序 处理和为每个浮点参数分配FP寄存器的规则传递。分配的方法是，满足该浮点参数需要的且编号最小的一组连续的FP寄存器中，第一个整数参数，通过寄存器 R0～R3来传递，其他参数通过数据栈传递。

子程序结果返回规则
===
子程序中结果返回的规则如下,

如果结果为一个32位的整数，可以通过寄存器返回。
如果结果为一个64位整数，可以通过寄存器R0和R1返回，依此类推。
如果结果为一个浮点数，可以通过浮点运算的寄存器F0、D0或S0返回。
如果结果为复合型的浮点数(如复数)，可以通过寄存器F0～FN或者D0～DN返回。

对于为数更多的结果，需要通过内存来传递。